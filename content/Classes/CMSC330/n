---
title: Regular Expressions
---

# Introduction
All problems can be solved with some minimum set of directions (or phrases). We call this set a **minimum language** for a problem.

> [!Example] Example: Minimum Language
> Say we have a problem where we need to know how we can move between two points using the cardinal directions. Then, our minimum language would be the set
> 
> $$
> \{ \text{North}, \text{East}, \text{South}, \text{West} \}
> $$

For many text-based problems in computer science, this minimum language can be expressed in terms of **regular expressions**, patterns that describe a set of strings. We can use regular expressions for simple text matching, yet their capabilities can extend far beyond that!
> However, regular expressions do have their limitations - due to the lack of a concept of memory, symbols in regular expressions are independent of one another, and cannot establish dependencies.

> [!Info] Note
> We will often prepend and append our pattern string with `/` to denote a regular expression. 


# Base Constructs
To describe a regular expression, we have the following **base constructs**. These are symbols or concepts that are necessary in describing regular expressions.

### (1) Alphabet
First, an **alphabet**, a set of symbols in the string. In regular expressions, this is commonly the english alphabet with characters "a"-"z" (lowercase and uppercase), and related symbols.

### (2) Concatenation
Next, **concatenation**, rules describing how symbols can combine with one another. This commonly occurs through the grouping of characters together.
```bash
"a" # Denotes the set {"a"}
"hello" # Denotes the set {"hello"}
```

### (3) Boolean
Next, **boolean**, an operator specifying how to group symbol constructs together in the same set. This is commonly done with the `OR` operator (`|`), which operates from the start of the expression to the end of the expression (or another `OR` operator).
```bash
"a|b|c" # Denotes {"a","b","c"}
"gray|grey" # Denotes {"gray", "grey"}. Note how we cannot share symbols.
```

To include characters in a range, we can use the **bracket operator** (`[ ]`), allowing us to specify any ASCII range of characters.
```bash
"(0|1|2|3|4|5|6|7|8|9)" # Denotes the set of characters from "0" to "9"
"[0-9]" # Equivalent to above

"[a-z]" # Any character in the range "a" to "z"
"[A-Za-z]" # Equivalent to "[A-Z]|[a-z]", any character in the range "A" to "Z" and "a" to "z"
```
> We can use the `.` operator to denote any character.

We can additionally include the `NOT` operator (`^`) in these bracket operations, to negative single characters.
```bash
"[^aei]" # Negatives a, e, i
```

### (4) Precedence
Next, **precedence**, symbols (`( )`) that allow us to limit the scope of the `OR` operator. This lets us share symbols between related strings.
```bash
# Notice how with precedence, we can share symbols!
"gr(a|e)y" # Denotes the set {"gray", "grey"}
```

Some nifty symbols we have to force order of characters `^` and `$`, to denote the start and end of the string (respectively).
```bash
"^[0-9]" # Must begin with a digit
"[0-9]$" # Must end with a digit
```

### (5) Quantification
Finally, **quantification**, symbols (`{ }`) that denote the number of repetitions of some expreeion that we want.
```bash
"(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)" # Set of all 2 digit strings
"(0|1|2|3|4|5|6|7|8|9){2}" # Equivalent to the above

"(0|1|2|3|4|5|6|7|8|9){2,5}" # Set of all 2 digit to 5 digit strings (inclusive)
```

For infinite quantification, we have the **kleene operator** (`*`), telling us that the previous regular expression is to be repeated 0 or more times.
```bash
"(ha)*" # Denotes the set {"", "ha", "haha", "hahaha", ... }
```
> Use `+` instead for at least 1 repetition, and use `?` for only 0 or 1 repeats.


## REGEX in Python
To perform regular expressions in Python, we first need to import the respective regular expression module, `re`.
> We can also use the PYTHEX website to test python regular expression matching!

```python
import re # Lets us perform regular expression matching
```

Then, using this module, we can create a regular expression using `re.compile()`, and attempt to match it using `match()`

```python
my_regex = re.compile("[0-9]") # Creates set of characters "0" to "9"

my_regex.match("2") # TRUE, matches
my_regex.match("hello!") # FALSE, doesn't match
```